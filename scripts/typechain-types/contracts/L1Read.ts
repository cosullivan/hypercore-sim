/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
  TypedContractMethod,
} from "../common";

export declare namespace L1Read {
  export type DelegationStruct = {
    validator: AddressLike;
    amount: BigNumberish;
    lockedUntilTimestamp: BigNumberish;
  };

  export type DelegationStructOutput = [
    validator: string,
    amount: bigint,
    lockedUntilTimestamp: bigint
  ] & { validator: string; amount: bigint; lockedUntilTimestamp: bigint };

  export type DelegatorSummaryStruct = {
    delegated: BigNumberish;
    undelegated: BigNumberish;
    totalPendingWithdrawal: BigNumberish;
    nPendingWithdrawals: BigNumberish;
  };

  export type DelegatorSummaryStructOutput = [
    delegated: bigint,
    undelegated: bigint,
    totalPendingWithdrawal: bigint,
    nPendingWithdrawals: bigint
  ] & {
    delegated: bigint;
    undelegated: bigint;
    totalPendingWithdrawal: bigint;
    nPendingWithdrawals: bigint;
  };

  export type PerpAssetInfoStruct = {
    coin: string;
    marginTableId: BigNumberish;
    szDecimals: BigNumberish;
    maxLeverage: BigNumberish;
    onlyIsolated: boolean;
  };

  export type PerpAssetInfoStructOutput = [
    coin: string,
    marginTableId: bigint,
    szDecimals: bigint,
    maxLeverage: bigint,
    onlyIsolated: boolean
  ] & {
    coin: string;
    marginTableId: bigint;
    szDecimals: bigint;
    maxLeverage: bigint;
    onlyIsolated: boolean;
  };

  export type PositionStruct = {
    szi: BigNumberish;
    entryNtl: BigNumberish;
    isolatedRawUsd: BigNumberish;
    leverage: BigNumberish;
    isIsolated: boolean;
  };

  export type PositionStructOutput = [
    szi: bigint,
    entryNtl: bigint,
    isolatedRawUsd: bigint,
    leverage: bigint,
    isIsolated: boolean
  ] & {
    szi: bigint;
    entryNtl: bigint;
    isolatedRawUsd: bigint;
    leverage: bigint;
    isIsolated: boolean;
  };

  export type SpotBalanceStruct = {
    total: BigNumberish;
    hold: BigNumberish;
    entryNtl: BigNumberish;
  };

  export type SpotBalanceStructOutput = [
    total: bigint,
    hold: bigint,
    entryNtl: bigint
  ] & { total: bigint; hold: bigint; entryNtl: bigint };

  export type SpotInfoStruct = {
    name: string;
    tokens: [BigNumberish, BigNumberish];
  };

  export type SpotInfoStructOutput = [
    name: string,
    tokens: [bigint, bigint]
  ] & { name: string; tokens: [bigint, bigint] };

  export type TokenInfoStruct = {
    name: string;
    spots: BigNumberish[];
    deployerTradingFeeShare: BigNumberish;
    deployer: AddressLike;
    evmContract: AddressLike;
    szDecimals: BigNumberish;
    weiDecimals: BigNumberish;
    evmExtraWeiDecimals: BigNumberish;
  };

  export type TokenInfoStructOutput = [
    name: string,
    spots: bigint[],
    deployerTradingFeeShare: bigint,
    deployer: string,
    evmContract: string,
    szDecimals: bigint,
    weiDecimals: bigint,
    evmExtraWeiDecimals: bigint
  ] & {
    name: string;
    spots: bigint[];
    deployerTradingFeeShare: bigint;
    deployer: string;
    evmContract: string;
    szDecimals: bigint;
    weiDecimals: bigint;
    evmExtraWeiDecimals: bigint;
  };

  export type UserVaultEquityStruct = {
    equity: BigNumberish;
    lockedUntilTimestamp: BigNumberish;
  };

  export type UserVaultEquityStructOutput = [
    equity: bigint,
    lockedUntilTimestamp: bigint
  ] & { equity: bigint; lockedUntilTimestamp: bigint };

  export type WithdrawableStruct = { withdrawable: BigNumberish };

  export type WithdrawableStructOutput = [withdrawable: bigint] & {
    withdrawable: bigint;
  };
}

export interface L1ReadInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "delegations"
      | "delegatorSummary"
      | "l1BlockNumber"
      | "markPx"
      | "oraclePx"
      | "perpAssetInfo"
      | "position"
      | "spotBalance"
      | "spotInfo"
      | "spotPx"
      | "tokenInfo"
      | "userVaultEquity"
      | "withdrawable"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "delegations",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "delegatorSummary",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "l1BlockNumber",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "markPx",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "oraclePx",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "perpAssetInfo",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "position",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "spotBalance",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "spotInfo",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "spotPx",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "tokenInfo",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "userVaultEquity",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawable",
    values: [AddressLike]
  ): string;

  decodeFunctionResult(
    functionFragment: "delegations",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "delegatorSummary",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "l1BlockNumber",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "markPx", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "oraclePx", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "perpAssetInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "position", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "spotBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "spotInfo", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "spotPx", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "tokenInfo", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "userVaultEquity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawable",
    data: BytesLike
  ): Result;
}

export interface L1Read extends BaseContract {
  connect(runner?: ContractRunner | null): L1Read;
  waitForDeployment(): Promise<this>;

  interface: L1ReadInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  delegations: TypedContractMethod<
    [user: AddressLike],
    [L1Read.DelegationStructOutput[]],
    "view"
  >;

  delegatorSummary: TypedContractMethod<
    [user: AddressLike],
    [L1Read.DelegatorSummaryStructOutput],
    "view"
  >;

  l1BlockNumber: TypedContractMethod<[], [bigint], "view">;

  markPx: TypedContractMethod<[index: BigNumberish], [bigint], "view">;

  oraclePx: TypedContractMethod<[index: BigNumberish], [bigint], "view">;

  perpAssetInfo: TypedContractMethod<
    [perp: BigNumberish],
    [L1Read.PerpAssetInfoStructOutput],
    "view"
  >;

  position: TypedContractMethod<
    [user: AddressLike, perp: BigNumberish],
    [L1Read.PositionStructOutput],
    "view"
  >;

  spotBalance: TypedContractMethod<
    [user: AddressLike, token: BigNumberish],
    [L1Read.SpotBalanceStructOutput],
    "view"
  >;

  spotInfo: TypedContractMethod<
    [spot: BigNumberish],
    [L1Read.SpotInfoStructOutput],
    "view"
  >;

  spotPx: TypedContractMethod<[index: BigNumberish], [bigint], "view">;

  tokenInfo: TypedContractMethod<
    [token: BigNumberish],
    [L1Read.TokenInfoStructOutput],
    "view"
  >;

  userVaultEquity: TypedContractMethod<
    [user: AddressLike, vault: AddressLike],
    [L1Read.UserVaultEquityStructOutput],
    "view"
  >;

  withdrawable: TypedContractMethod<
    [user: AddressLike],
    [L1Read.WithdrawableStructOutput],
    "view"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "delegations"
  ): TypedContractMethod<
    [user: AddressLike],
    [L1Read.DelegationStructOutput[]],
    "view"
  >;
  getFunction(
    nameOrSignature: "delegatorSummary"
  ): TypedContractMethod<
    [user: AddressLike],
    [L1Read.DelegatorSummaryStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "l1BlockNumber"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "markPx"
  ): TypedContractMethod<[index: BigNumberish], [bigint], "view">;
  getFunction(
    nameOrSignature: "oraclePx"
  ): TypedContractMethod<[index: BigNumberish], [bigint], "view">;
  getFunction(
    nameOrSignature: "perpAssetInfo"
  ): TypedContractMethod<
    [perp: BigNumberish],
    [L1Read.PerpAssetInfoStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "position"
  ): TypedContractMethod<
    [user: AddressLike, perp: BigNumberish],
    [L1Read.PositionStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "spotBalance"
  ): TypedContractMethod<
    [user: AddressLike, token: BigNumberish],
    [L1Read.SpotBalanceStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "spotInfo"
  ): TypedContractMethod<
    [spot: BigNumberish],
    [L1Read.SpotInfoStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "spotPx"
  ): TypedContractMethod<[index: BigNumberish], [bigint], "view">;
  getFunction(
    nameOrSignature: "tokenInfo"
  ): TypedContractMethod<
    [token: BigNumberish],
    [L1Read.TokenInfoStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "userVaultEquity"
  ): TypedContractMethod<
    [user: AddressLike, vault: AddressLike],
    [L1Read.UserVaultEquityStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "withdrawable"
  ): TypedContractMethod<
    [user: AddressLike],
    [L1Read.WithdrawableStructOutput],
    "view"
  >;

  filters: {};
}
