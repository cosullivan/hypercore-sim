/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
  TypedContractMethod,
} from "../common";

export declare namespace L1Read {
  export type DelegationStruct = {
    validator: AddressLike;
    amount: BigNumberish;
    lockedUntilTimestamp: BigNumberish;
  };

  export type DelegationStructOutput = [
    validator: string,
    amount: bigint,
    lockedUntilTimestamp: bigint
  ] & { validator: string; amount: bigint; lockedUntilTimestamp: bigint };

  export type DelegatorSummaryStruct = {
    delegated: BigNumberish;
    undelegated: BigNumberish;
    totalPendingWithdrawal: BigNumberish;
    nPendingWithdrawals: BigNumberish;
  };

  export type DelegatorSummaryStructOutput = [
    delegated: bigint,
    undelegated: bigint,
    totalPendingWithdrawal: bigint,
    nPendingWithdrawals: bigint
  ] & {
    delegated: bigint;
    undelegated: bigint;
    totalPendingWithdrawal: bigint;
    nPendingWithdrawals: bigint;
  };

  export type PositionStruct = {
    szi: BigNumberish;
    entryNtl: BigNumberish;
    isolatedRawUsd: BigNumberish;
    leverage: BigNumberish;
    isIsolated: boolean;
  };

  export type PositionStructOutput = [
    szi: bigint,
    entryNtl: bigint,
    isolatedRawUsd: bigint,
    leverage: bigint,
    isIsolated: boolean
  ] & {
    szi: bigint;
    entryNtl: bigint;
    isolatedRawUsd: bigint;
    leverage: bigint;
    isIsolated: boolean;
  };

  export type SpotBalanceStruct = {
    total: BigNumberish;
    hold: BigNumberish;
    entryNtl: BigNumberish;
  };

  export type SpotBalanceStructOutput = [
    total: bigint,
    hold: bigint,
    entryNtl: bigint
  ] & { total: bigint; hold: bigint; entryNtl: bigint };

  export type TokenInfoStruct = {
    name: string;
    spots: BigNumberish[];
    deployerTradingFeeShare: BigNumberish;
    deployer: AddressLike;
    evmContract: AddressLike;
    szDecimals: BigNumberish;
    weiDecimals: BigNumberish;
    evmExtraWeiDecimals: BigNumberish;
  };

  export type TokenInfoStructOutput = [
    name: string,
    spots: bigint[],
    deployerTradingFeeShare: bigint,
    deployer: string,
    evmContract: string,
    szDecimals: bigint,
    weiDecimals: bigint,
    evmExtraWeiDecimals: bigint
  ] & {
    name: string;
    spots: bigint[];
    deployerTradingFeeShare: bigint;
    deployer: string;
    evmContract: string;
    szDecimals: bigint;
    weiDecimals: bigint;
    evmExtraWeiDecimals: bigint;
  };

  export type UserVaultEquityStruct = {
    equity: BigNumberish;
    lockedUntilTimestamp: BigNumberish;
  };

  export type UserVaultEquityStructOutput = [
    equity: bigint,
    lockedUntilTimestamp: bigint
  ] & { equity: bigint; lockedUntilTimestamp: bigint };

  export type WithdrawableStruct = { withdrawable: BigNumberish };

  export type WithdrawableStructOutput = [withdrawable: bigint] & {
    withdrawable: bigint;
  };
}

export interface HyperCoreInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "deploySpotERC20"
      | "executeCDeposit"
      | "executeCWithdrawal"
      | "executeNativeTransfer"
      | "executeSpot"
      | "executeTokenDelegate"
      | "executeTokenTransfer"
      | "executeUsdClassTransfer"
      | "executeVaultTransfer"
      | "flushCWithdrawQueue"
      | "forceAccountCreation"
      | "forcePerp"
      | "forceSpot"
      | "forceVaultEquity"
      | "readDelegations"
      | "readDelegatorSummary"
      | "readPosition"
      | "readSpotBalance"
      | "readTokenInfo"
      | "readUserVaultEquity"
      | "readWithdrawable"
      | "registerTokenInfo"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "deploySpotERC20",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "executeCDeposit",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "executeCWithdrawal",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "executeNativeTransfer",
    values: [AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "executeSpot",
    values: [AddressLike, AddressLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "executeTokenDelegate",
    values: [AddressLike, AddressLike, BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "executeTokenTransfer",
    values: [AddressLike, BigNumberish, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "executeUsdClassTransfer",
    values: [AddressLike, BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "executeVaultTransfer",
    values: [AddressLike, AddressLike, boolean, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "flushCWithdrawQueue",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "forceAccountCreation",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "forcePerp",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "forceSpot",
    values: [AddressLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "forceVaultEquity",
    values: [AddressLike, AddressLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "readDelegations",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "readDelegatorSummary",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "readPosition",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "readSpotBalance",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "readTokenInfo",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "readUserVaultEquity",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "readWithdrawable",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "registerTokenInfo",
    values: [BigNumberish, L1Read.TokenInfoStruct]
  ): string;

  decodeFunctionResult(
    functionFragment: "deploySpotERC20",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeCDeposit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeCWithdrawal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeNativeTransfer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeSpot",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeTokenDelegate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeTokenTransfer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeUsdClassTransfer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeVaultTransfer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "flushCWithdrawQueue",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "forceAccountCreation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "forcePerp", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "forceSpot", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "forceVaultEquity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "readDelegations",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "readDelegatorSummary",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "readPosition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "readSpotBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "readTokenInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "readUserVaultEquity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "readWithdrawable",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registerTokenInfo",
    data: BytesLike
  ): Result;
}

export interface HyperCore extends BaseContract {
  connect(runner?: ContractRunner | null): HyperCore;
  waitForDeployment(): Promise<this>;

  interface: HyperCoreInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  deploySpotERC20: TypedContractMethod<
    [index: BigNumberish],
    [string],
    "nonpayable"
  >;

  executeCDeposit: TypedContractMethod<
    [sender: AddressLike, _wei: BigNumberish],
    [void],
    "nonpayable"
  >;

  executeCWithdrawal: TypedContractMethod<
    [sender: AddressLike, _wei: BigNumberish],
    [void],
    "nonpayable"
  >;

  executeNativeTransfer: TypedContractMethod<
    [arg0: AddressLike, from: AddressLike, value: BigNumberish],
    [void],
    "payable"
  >;

  executeSpot: TypedContractMethod<
    [
      sender: AddressLike,
      destination: AddressLike,
      token: BigNumberish,
      _wei: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  executeTokenDelegate: TypedContractMethod<
    [
      sender: AddressLike,
      validator: AddressLike,
      _wei: BigNumberish,
      isUndelegate: boolean
    ],
    [void],
    "nonpayable"
  >;

  executeTokenTransfer: TypedContractMethod<
    [
      arg0: AddressLike,
      token: BigNumberish,
      from: AddressLike,
      value: BigNumberish
    ],
    [void],
    "payable"
  >;

  executeUsdClassTransfer: TypedContractMethod<
    [sender: AddressLike, ntl: BigNumberish, toPerp: boolean],
    [void],
    "nonpayable"
  >;

  executeVaultTransfer: TypedContractMethod<
    [
      sender: AddressLike,
      vault: AddressLike,
      isDeposit: boolean,
      usd: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  flushCWithdrawQueue: TypedContractMethod<[], [void], "nonpayable">;

  forceAccountCreation: TypedContractMethod<
    [account: AddressLike],
    [void],
    "nonpayable"
  >;

  forcePerp: TypedContractMethod<
    [account: AddressLike, usd: BigNumberish],
    [void],
    "nonpayable"
  >;

  forceSpot: TypedContractMethod<
    [account: AddressLike, token: BigNumberish, _wei: BigNumberish],
    [void],
    "nonpayable"
  >;

  forceVaultEquity: TypedContractMethod<
    [
      account: AddressLike,
      vault: AddressLike,
      usd: BigNumberish,
      lockedUntilTimestamp: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  readDelegations: TypedContractMethod<
    [user: AddressLike],
    [L1Read.DelegationStructOutput[]],
    "view"
  >;

  readDelegatorSummary: TypedContractMethod<
    [user: AddressLike],
    [L1Read.DelegatorSummaryStructOutput],
    "view"
  >;

  readPosition: TypedContractMethod<
    [user: AddressLike, perp: BigNumberish],
    [L1Read.PositionStructOutput],
    "view"
  >;

  readSpotBalance: TypedContractMethod<
    [account: AddressLike, token: BigNumberish],
    [L1Read.SpotBalanceStructOutput],
    "view"
  >;

  readTokenInfo: TypedContractMethod<
    [token: BigNumberish],
    [L1Read.TokenInfoStructOutput],
    "view"
  >;

  readUserVaultEquity: TypedContractMethod<
    [user: AddressLike, vault: AddressLike],
    [L1Read.UserVaultEquityStructOutput],
    "view"
  >;

  readWithdrawable: TypedContractMethod<
    [account: AddressLike],
    [L1Read.WithdrawableStructOutput],
    "view"
  >;

  registerTokenInfo: TypedContractMethod<
    [index: BigNumberish, tokenInfo: L1Read.TokenInfoStruct],
    [void],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "deploySpotERC20"
  ): TypedContractMethod<[index: BigNumberish], [string], "nonpayable">;
  getFunction(
    nameOrSignature: "executeCDeposit"
  ): TypedContractMethod<
    [sender: AddressLike, _wei: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "executeCWithdrawal"
  ): TypedContractMethod<
    [sender: AddressLike, _wei: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "executeNativeTransfer"
  ): TypedContractMethod<
    [arg0: AddressLike, from: AddressLike, value: BigNumberish],
    [void],
    "payable"
  >;
  getFunction(
    nameOrSignature: "executeSpot"
  ): TypedContractMethod<
    [
      sender: AddressLike,
      destination: AddressLike,
      token: BigNumberish,
      _wei: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "executeTokenDelegate"
  ): TypedContractMethod<
    [
      sender: AddressLike,
      validator: AddressLike,
      _wei: BigNumberish,
      isUndelegate: boolean
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "executeTokenTransfer"
  ): TypedContractMethod<
    [
      arg0: AddressLike,
      token: BigNumberish,
      from: AddressLike,
      value: BigNumberish
    ],
    [void],
    "payable"
  >;
  getFunction(
    nameOrSignature: "executeUsdClassTransfer"
  ): TypedContractMethod<
    [sender: AddressLike, ntl: BigNumberish, toPerp: boolean],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "executeVaultTransfer"
  ): TypedContractMethod<
    [
      sender: AddressLike,
      vault: AddressLike,
      isDeposit: boolean,
      usd: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "flushCWithdrawQueue"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "forceAccountCreation"
  ): TypedContractMethod<[account: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "forcePerp"
  ): TypedContractMethod<
    [account: AddressLike, usd: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "forceSpot"
  ): TypedContractMethod<
    [account: AddressLike, token: BigNumberish, _wei: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "forceVaultEquity"
  ): TypedContractMethod<
    [
      account: AddressLike,
      vault: AddressLike,
      usd: BigNumberish,
      lockedUntilTimestamp: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "readDelegations"
  ): TypedContractMethod<
    [user: AddressLike],
    [L1Read.DelegationStructOutput[]],
    "view"
  >;
  getFunction(
    nameOrSignature: "readDelegatorSummary"
  ): TypedContractMethod<
    [user: AddressLike],
    [L1Read.DelegatorSummaryStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "readPosition"
  ): TypedContractMethod<
    [user: AddressLike, perp: BigNumberish],
    [L1Read.PositionStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "readSpotBalance"
  ): TypedContractMethod<
    [account: AddressLike, token: BigNumberish],
    [L1Read.SpotBalanceStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "readTokenInfo"
  ): TypedContractMethod<
    [token: BigNumberish],
    [L1Read.TokenInfoStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "readUserVaultEquity"
  ): TypedContractMethod<
    [user: AddressLike, vault: AddressLike],
    [L1Read.UserVaultEquityStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "readWithdrawable"
  ): TypedContractMethod<
    [account: AddressLike],
    [L1Read.WithdrawableStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "registerTokenInfo"
  ): TypedContractMethod<
    [index: BigNumberish, tokenInfo: L1Read.TokenInfoStruct],
    [void],
    "nonpayable"
  >;

  filters: {};
}
